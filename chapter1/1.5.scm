;; 练习1.5 Ben Bitdidlle发明了一种检测方法，能够确定解释器究竟采用哪种序求值，
;; 是采用应用序，还是采用正则序。他定义了下面连个过程：

(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y))
;; 而后他求值下面的表达式：
(test 0 (p))

;; 如果某个解释器采用的是应用序求值，Ben会看到什么样的情况？ 如果解释器采用
;; 正则序求值他有会看到什么情况？请对你的回答做出解释。（无论采用正则序或者
;; 应用序，假定特殊形式if的求值规则总是一样的。其中的谓词部分先行求值，根据
;; 其结果确定随后求值的子表达式部分。)

;; 解：这要看对正则序和应用序的定义，在书中找到，“完全展开而后规约的求值
;; 模型为正则序求值”，“先求值参数而后应用的方式为应用求值模型”。
;; 按照这样说，正则序应该不能给出结果，因为展开p的时候会变为无限展开，而应该
;; 序则不会，所以，正则序会出现死循环，而应用序能得到结果0

;; 后来有看了一遍书，书中还有对于应用序的描述是：“解释器首先对运算符和各个
;; 运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数”。而对正则
;; 序的描述是：“先不求出运算对象的值，直到实际需要他们的值时再去做，采用这种
;; 求值方式，我们就应该首先用运算对象表达式去代换形式参数，知道得到一个只包含
;; 基本运算符的表达式，然后再去执行求值”。
;; 那么正则序和应用序的区别就是实际参数在什么时候求值，前者是在完成展开运算
;; 符后，后者是在一边展开运算符一边求值。就是说应用序会比正则序有一个优点，
;; 就是有可能减少实际参数的求值次数，或者有可能应用序的出现就是用来正则序的
;; 那个缺点。这个区别在这个题目中就显现出来了。
;; 按照上面所说的，应用序在开始的时候会对运算符和各个运算对象求值，那么求值
;; 运算对象(p)的时候就出现先死循环。而正则序会先展开，展开后变成了if表达式，
;; 而根据题目说的if求值规则是其中的谓词部分先行求值，那个if表达是的值就是0了，
;; 而不会出现对(p)的求值了。即正则序的结果是0
