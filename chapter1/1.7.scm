;; 练习1.7 对于确定很小的书的平方根而言，在计算平方根中使用的检测
;; good-enough?是很不好的。还有，在现实的计算机里，算术运算总是以
;; 一定的有限精度进行的。这也会使我们的检测不适合非常大的数的计算。
;; 请解释上述论断，用例子说明对很小和很大的数，这中检测都有可能失败。
;; 实现good-enough?的另一种策略是监视猜测值在从一次迭代到下一次迭代
;; 的变化情况，当改变值相对于猜测值的比率很小时就结束，请设计一个采用
;; 这中终止测试方式的平方根过程。对于很大很很小的数，这一方式都能工作
;; 吗?
;;
;; 解：这里应该是一个精度设计的问题，这里有一个精度的问题，现在的精度
;; 是0.001,当求一个比较小的数的时候会出问题。比如

;; (good-enough? 0.01 0.001)

;; 0.01是一个不合适的值但是这个会返回它是一个合适的值.当然我们可以把精度
;; 设的很细小，比如
;; (define (good-enough? guess x)
;;  (< (abs (- (square guess) x)) 0.0001))
;; 那个前面那个函数返回的就会是正确的值
;;(good-enough? 0.01 0.001)

;; 但还是会有另一个问题就是算术运算总是以一定的有限精度运行的，当求一个很大
;; 的数据的时候由于精度的损失，有时候求到了一个很接近的值，但由于他们的差不
;; 小于0.001，返回会返回这个值不适合，然后调用improve函数去求一个更接近的数，
;; 由于计算精度的问题，improve函数有可能返回返回上一个猜测的数，那个程序就会
;; 进入无限循环，比如

;; (good-enough? 3162277.6601683795 10000000000000)
;; (sqrt 10000000000000)  ;; 求值这个表达式会进入无限循环

(define (good-enough? prev next)
  (< (abs (- prev next)) (* 0.001 next)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (sqrt-iter prev next x)
  (if (good-enough? prev next)
    next
    (sqrt-iter next (improve next x) x)))

(define (sqrt x)
  (sqrt-iter 1.1 1.0 x))

(sqrt 4)

;; 上面这中采用监视猜测值在一次迭代到下一次的变化情况，当改变值相对于猜测值的比例
;; 很小时就结束的策略终止测试方式的平方根过程，对于很大的数和很的数，这一方式都能
;; 工作。因为这样终止的方式和数的大小不相关，它关心的是这次猜测值和下次猜测的改变
;; 量，也就是继续猜下去能对结果改进过多少。当改进太小是就结束。而不是监视当前值和
;; 真值之间的差异。
